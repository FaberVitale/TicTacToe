{"version":3,"sources":["../static/js/1.e87ec8ec.chunk.js","components/MousetrapWrapper.js","../node_modules/mousetrap/mousetrap.js","containers/KeyBinder.js"],"names":["webpackJsonp","189","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_1_prop_types__","n","__WEBPACK_IMPORTED_MODULE_1_prop_types___default","__WEBPACK_IMPORTED_MODULE_2_mousetrap__","__WEBPACK_IMPORTED_MODULE_2_mousetrap___default","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","MousetrapWrapper","_Component","this","_this","getPrototypeOf","state","bindings","a","bind","unbind","propTypes","objectOf","func","190","exports","__WEBPACK_AMD_DEFINE_RESULT__","window","document","undefined","_addEvent","object","type","callback","addEventListener","attachEvent","_characterFromEvent","e","character","String","fromCharCode","which","shiftKey","toLowerCase","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","sort","join","_eventModifiers","modifiers","push","altKey","ctrlKey","metaKey","_preventDefault","preventDefault","returnValue","_stopPropagation","stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","hasOwnProperty","_pickBestAction","action","_keysFromString","combination","replace","split","_getKeyInfo","keys","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","element","ancestor","parentNode","Mousetrap","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","matches","_callbacks","seq","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","stopCallback","srcElement","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","clearTimeout","_resetTimer","setTimeout","_bindSequence","_callbackAndReset","isFinal","wrappedCallback","nextAction","_bindSingle","_directMap","info","_ignoreNextKeypress","_handleKey","callbacks","maxLevel","processedSequenceCallback","Math","max","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","191","192","219","220","221","222","~","!","@","#","$","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","option","command","return","escape","plus","mod","test","navigator","platform","toString","Array","trigger","reset","className","indexOf","tagName","isContentEditable","apply","arguments","addKeycodes","init","documentMousetrap","method","charAt","76","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__","__WEBPACK_IMPORTED_MODULE_2_react_redux__","__WEBPACK_IMPORTED_MODULE_3__selectors__","__WEBPACK_IMPORTED_MODULE_4__constants__","__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__","simulateClick","buttonId","elem","activeElement","focus","click","blur","throttledSimulateClick","focusSelect","id","KeyBinder","_ref","_temp","_ret","_len","args","_key","concat","triggerIf","cb","shouldTrigger","isGT","isGO","focusId","selected","startsWith","parseInt","slice","board","empty","lastIndexOf","$id","moveLeft","move","moveRIght","moveUp","moveDown","undo","redo","createElement","w","s","d","ctrl+z","ctrl+shift+z","ctrl+y","m","mapStateToProps"],"mappings":"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","file":"static/js/1.e87ec8ec.chunk.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 189:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_mousetrap__ = __webpack_require__(190);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_mousetrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_mousetrap__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var MousetrapWrapper=function(_Component){_inherits(MousetrapWrapper,_Component);function MousetrapWrapper(props){_classCallCheck(this,MousetrapWrapper);var _this=_possibleConstructorReturn(this,(MousetrapWrapper.__proto__||Object.getPrototypeOf(MousetrapWrapper)).call(this,props));_this.state={bindings:props.bindings};return _this;}_createClass(MousetrapWrapper,[{key:\"shouldComponentUpdate\",value:function shouldComponentUpdate(){return false;}},{key:\"componentDidMount\",value:function componentDidMount(){for(var key in this.state.bindings){__WEBPACK_IMPORTED_MODULE_2_mousetrap___default.a.bind(key,this.state.bindings[key]);}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){for(var key in this.state.bindings){__WEBPACK_IMPORTED_MODULE_2_mousetrap___default.a.unbind(key);}}},{key:\"render\",value:function render(){return null;}}]);return MousetrapWrapper;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);MousetrapWrapper.propTypes={bindings:__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.objectOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func)};/* harmony default export */ __webpack_exports__[\"a\"] = (MousetrapWrapper);\n\n/***/ }),\n\n/***/ 190:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n            return Mousetrap;\n        }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ }),\n\n/***/ 76:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__ = __webpack_require__(189);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_redux__ = __webpack_require__(17);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__selectors__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_functionUtil__ = __webpack_require__(6);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var simulateClick=function simulateClick(buttonId){return function(){var elem=buttonId?Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(buttonId)||document.activeElement:document.activeElement;if(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"a\" /* $disabled */])(elem)){return;}if(elem!==document.activeElement){elem.focus();}elem.click();if(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"a\" /* $disabled */])(elem)){elem.blur();//firefox keeps disabled buttons focused\n}};};var throttledSimulateClick=Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick());var focusSelect=function focusSelect(){if(document.activeElement.id!==\"mode-list\"){Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(\"mode-list\").focus();}};var KeyBinder=function(_Component){_inherits(KeyBinder,_Component);function KeyBinder(){var _ref;var _temp,_this,_ret;_classCallCheck(this,KeyBinder);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=KeyBinder.__proto__||Object.getPrototypeOf(KeyBinder)).call.apply(_ref,[this].concat(args))),_this),_this.triggerIf=function(cb){return function(){if(_this.props.shouldTrigger){cb();}};},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(KeyBinder,[{key:\"shouldComponentUpdate\",value:function shouldComponentUpdate(){return false;}},{key:\"move\",value:function move(mod,isGT){if(this.props.isGO){return;}var focusId=document.activeElement.id;var selected=void 0;if(!focusId||!focusId.startsWith(\"cell-\")){selected=this.props.board.indexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty);}else{var currIndex=parseInt(focusId.slice(5),10);selected=currIndex+mod;if(selected<0||selected>8){return;}if(this.props.board[selected]!==__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty){selected=isGT?this.props.board.indexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty,selected+1):this.props.board.lastIndexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty,selected-1);}}if(selected>-1){Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(\"cell-\"+selected).focus();}}},{key:\"render\",value:function render(){var moveLeft=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,-1,false)));var moveRIght=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,1,true)));var moveUp=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,-3,false)));var moveDown=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,3,true)));var undo=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"undo\")));var redo=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"redo\")));return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__[\"a\" /* default */],{bindings:{w:moveUp,a:moveLeft,s:moveDown,d:moveRIght,e:this.triggerIf(throttledSimulateClick),\"ctrl+z\":undo,\"ctrl+shift+z\":redo,\"ctrl+y\":redo,n:this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"new\"))),m:this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],focusSelect))}});}}]);return KeyBinder;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{board:Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"d\" /* getBoard */])(state),isGO:Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"m\" /* isGameOver */])(state),shouldTrigger:!Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"g\" /* getModalState */])(state)};};/* harmony default export */ __webpack_exports__[\"default\"] = (Object(__WEBPACK_IMPORTED_MODULE_2_react_redux__[\"b\" /* connect */])(mapStateToProps,null)(KeyBinder));\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/1.e87ec8ec.chunk.js","import { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Mousetrap from \"mousetrap\";\n\nclass MousetrapWrapper extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      bindings: props.bindings\n    };\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  componentDidMount() {\n    for (let key in this.state.bindings) {\n      Mousetrap.bind(key, this.state.bindings[key]);\n    }\n  }\n\n  componentWillUnmount() {\n    for (let key in this.state.bindings) {\n      Mousetrap.unbind(key);\n    }\n  }\n\n  render() {\n    return null;\n  }\n}\n\nMousetrapWrapper.propTypes = {\n  bindings: PropTypes.objectOf(PropTypes.func)\n};\n\nexport default MousetrapWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/MousetrapWrapper.js","/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mousetrap/mousetrap.js\n// module id = 190\n// module chunks = 1","import React, { Component } from \"react\";\nimport MousetrapWrapper from \"../components/MousetrapWrapper\";\nimport { connect } from \"react-redux\";\nimport { getBoard, isGameOver, getModalState } from \"../selectors\";\nimport { symb, throttleTime } from \"../constants\";\nimport { throttle, $id, $disabled } from \"../util/functionUtil\";\n\nconst simulateClick = buttonId => {\n  return () => {\n    const elem = buttonId\n      ? $id(buttonId) || document.activeElement\n      : document.activeElement;\n\n    if ($disabled(elem)) {\n      return;\n    }\n\n    if (elem !== document.activeElement) {\n      elem.focus();\n    }\n\n    elem.click();\n\n    if ($disabled(elem)) {\n      elem.blur(); //firefox keeps disabled buttons focused\n    }\n  };\n};\n\nconst throttledSimulateClick = throttle(throttleTime, simulateClick());\n\nconst focusSelect = () => {\n  if (document.activeElement.id !== \"mode-list\") {\n    $id(\"mode-list\").focus();\n  }\n};\n\nclass KeyBinder extends Component {\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  triggerIf = cb => () => {\n    if (this.props.shouldTrigger) {\n      cb();\n    }\n  };\n\n  move(mod, isGT) {\n    if (this.props.isGO) {\n      return;\n    }\n\n    const focusId = document.activeElement.id;\n    let selected;\n\n    if (!focusId || !focusId.startsWith(\"cell-\")) {\n      selected = this.props.board.indexOf(symb.empty);\n    } else {\n      let currIndex = parseInt(focusId.slice(5), 10);\n\n      selected = currIndex + mod;\n\n      if (selected < 0 || selected > 8) {\n        return;\n      }\n\n      if (this.props.board[selected] !== symb.empty) {\n        selected = isGT\n          ? this.props.board.indexOf(symb.empty, selected + 1)\n          : this.props.board.lastIndexOf(symb.empty, selected - 1);\n      }\n    }\n\n    if (selected > -1) {\n      $id(`cell-${selected}`).focus();\n    }\n  }\n\n  render() {\n    const moveLeft = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, -1, false))\n    );\n\n    const moveRIght = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, 1, true))\n    );\n\n    const moveUp = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, -3, false))\n    );\n\n    const moveDown = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, 3, true))\n    );\n\n    const undo = this.triggerIf(throttle(throttleTime, simulateClick(\"undo\")));\n    const redo = this.triggerIf(throttle(throttleTime, simulateClick(\"redo\")));\n\n    return (\n      <MousetrapWrapper\n        bindings={{\n          w: moveUp,\n          a: moveLeft,\n          s: moveDown,\n          d: moveRIght,\n          e: this.triggerIf(throttledSimulateClick),\n          \"ctrl+z\": undo,\n          \"ctrl+shift+z\": redo,\n          \"ctrl+y\": redo,\n          n: this.triggerIf(throttle(throttleTime, simulateClick(\"new\"))),\n          m: this.triggerIf(throttle(throttleTime, focusSelect))\n        }}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  board: getBoard(state),\n  isGO: isGameOver(state),\n  shouldTrigger: !getModalState(state)\n});\n\nexport default connect(mapStateToProps, null)(KeyBinder);\n\n\n\n// WEBPACK FOOTER //\n// ./src/containers/KeyBinder.js"],"sourceRoot":""}