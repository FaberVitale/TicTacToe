{"version":3,"sources":["../static/js/0.b745c1bb.chunk.js","containers/KeyBinder.js","components/MousetrapWrapper.js","../node_modules/mousetrap/mousetrap.js"],"names":["webpackJsonp","190","module","__webpack_exports__","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__","__WEBPACK_IMPORTED_MODULE_2_react_redux__","__WEBPACK_IMPORTED_MODULE_3__selectors__","__WEBPACK_IMPORTED_MODULE_4__constants__","__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","simulateClick","buttonId","elem","document","activeElement","focus","click","blur","throttledSimulateClick","focusSelect","id","KeyBinder","_Component","_ref","_temp","_this","_ret","this","_len","arguments","args","Array","_key","getPrototypeOf","apply","concat","triggerIf","cb","shouldTrigger","mod","isGT","isGO","focusId","selected","startsWith","parseInt","slice","board","empty","indexOf","lastIndexOf","$id","moveLeft","move","bind","moveRIght","moveUp","moveDown","undo","redo","a","createElement","bindings","w","s","d","e","ctrl+z","ctrl+shift+z","ctrl+y","m","mapStateToProps","state","191","__WEBPACK_IMPORTED_MODULE_1_prop_types__","__WEBPACK_IMPORTED_MODULE_1_prop_types___default","__WEBPACK_IMPORTED_MODULE_2_mousetrap__","__WEBPACK_IMPORTED_MODULE_2_mousetrap___default","MousetrapWrapper","unbind","propTypes","objectOf","func","192","exports","__WEBPACK_AMD_DEFINE_RESULT__","window","undefined","_addEvent","object","type","callback","addEventListener","attachEvent","_characterFromEvent","character","String","fromCharCode","which","shiftKey","toLowerCase","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","sort","join","_eventModifiers","modifiers","push","altKey","ctrlKey","metaKey","_preventDefault","preventDefault","returnValue","_stopPropagation","stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","hasOwnProperty","_pickBestAction","action","_keysFromString","combination","replace","split","_getKeyInfo","keys","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","element","ancestor","parentNode","Mousetrap","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","matches","_callbacks","seq","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","stopCallback","srcElement","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","clearTimeout","_resetTimer","setTimeout","_bindSequence","_callbackAndReset","isFinal","wrappedCallback","nextAction","_bindSingle","_directMap","info","_ignoreNextKeypress","_handleKey","callbacks","maxLevel","processedSequenceCallback","Math","max","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","189","219","220","221","222","~","!","@","#","$","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","option","command","return","escape","plus","test","navigator","platform","toString","trigger","reset","className","tagName","isContentEditable","addKeycodes","init","documentMousetrap","method","charAt"],"mappings":"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","file":"static/js/0.b745c1bb.chunk.js","sourcesContent":["webpackJsonp([0],{\n\n/***/ 190:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__ = __webpack_require__(191);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react_redux__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__selectors__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_functionUtil__ = __webpack_require__(4);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var simulateClick=function simulateClick(buttonId){return function(){var elem=buttonId?Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(buttonId)||document.activeElement:document.activeElement;if(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"a\" /* $disabled */])(elem)){return;}if(elem!==document.activeElement){elem.focus();}elem.click();if(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"a\" /* $disabled */])(elem)){elem.blur();//firefox keeps disabled buttons focused\n}};};var throttledSimulateClick=Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick());var focusSelect=function focusSelect(){if(document.activeElement.id!==\"mode-list\"){Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(\"mode-list\").focus();}};var KeyBinder=function(_Component){_inherits(KeyBinder,_Component);function KeyBinder(){var _ref;var _temp,_this,_ret;_classCallCheck(this,KeyBinder);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return _ret=(_temp=(_this=_possibleConstructorReturn(this,(_ref=KeyBinder.__proto__||Object.getPrototypeOf(KeyBinder)).call.apply(_ref,[this].concat(args))),_this),_this.triggerIf=function(cb){return function(){if(_this.props.shouldTrigger){cb();}};},_temp),_possibleConstructorReturn(_this,_ret);}_createClass(KeyBinder,[{key:\"shouldComponentUpdate\",value:function shouldComponentUpdate(){return false;}},{key:\"move\",value:function move(mod,isGT){if(this.props.isGO){return;}var focusId=document.activeElement.id;var selected=void 0;if(!focusId||!focusId.startsWith(\"cell-\")){selected=this.props.board.indexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty);}else{var currIndex=parseInt(focusId.slice(5),10);selected=currIndex+mod;if(selected<0||selected>8){return;}if(this.props.board[selected]!==__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty){selected=isGT?this.props.board.indexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty,selected+1):this.props.board.lastIndexOf(__WEBPACK_IMPORTED_MODULE_4__constants__[\"l\" /* symb */].empty,selected-1);}}if(selected>-1){Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"b\" /* $id */])(\"cell-\"+selected).focus();}}},{key:\"render\",value:function render(){var moveLeft=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,-1,false)));var moveRIght=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,1,true)));var moveUp=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,-3,false)));var moveDown=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],this.move.bind(this,3,true)));var undo=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"undo\")));var redo=this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"redo\")));return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1__components_MousetrapWrapper__[\"a\" /* default */],{bindings:{w:moveUp,a:moveLeft,s:moveDown,d:moveRIght,e:this.triggerIf(throttledSimulateClick),\"ctrl+z\":undo,\"ctrl+shift+z\":redo,\"ctrl+y\":redo,n:this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],simulateClick(\"new\"))),m:this.triggerIf(Object(__WEBPACK_IMPORTED_MODULE_5__util_functionUtil__[\"e\" /* throttle */])(__WEBPACK_IMPORTED_MODULE_4__constants__[\"o\" /* throttleTime */],focusSelect))}});}}]);return KeyBinder;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);var mapStateToProps=function mapStateToProps(state){return{board:Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"d\" /* getBoard */])(state),isGO:Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"m\" /* isGameOver */])(state),shouldTrigger:!Object(__WEBPACK_IMPORTED_MODULE_3__selectors__[\"g\" /* getModalState */])(state)};};/* harmony default export */ __webpack_exports__[\"default\"] = (Object(__WEBPACK_IMPORTED_MODULE_2_react_redux__[\"b\" /* connect */])(mapStateToProps,null)(KeyBinder));\n\n/***/ }),\n\n/***/ 191:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_mousetrap__ = __webpack_require__(192);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_mousetrap___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_mousetrap__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var MousetrapWrapper=function(_Component){_inherits(MousetrapWrapper,_Component);function MousetrapWrapper(props){_classCallCheck(this,MousetrapWrapper);var _this=_possibleConstructorReturn(this,(MousetrapWrapper.__proto__||Object.getPrototypeOf(MousetrapWrapper)).call(this,props));_this.state={bindings:props.bindings};return _this;}_createClass(MousetrapWrapper,[{key:\"shouldComponentUpdate\",value:function shouldComponentUpdate(){return false;}},{key:\"componentDidMount\",value:function componentDidMount(){for(var key in this.state.bindings){__WEBPACK_IMPORTED_MODULE_2_mousetrap___default.a.bind(key,this.state.bindings[key]);}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){for(var key in this.state.bindings){__WEBPACK_IMPORTED_MODULE_2_mousetrap___default.a.unbind(key);}}},{key:\"render\",value:function render(){return null;}}]);return MousetrapWrapper;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"Component\"]);MousetrapWrapper.propTypes={bindings:__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.objectOf(__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func)};/* harmony default export */ __webpack_exports__[\"a\"] = (MousetrapWrapper);\n\n/***/ }),\n\n/***/ 192:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n            return Mousetrap;\n        }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/0.b745c1bb.chunk.js","import React, { Component } from \"react\";\nimport MousetrapWrapper from \"../components/MousetrapWrapper\";\nimport { connect } from \"react-redux\";\nimport { getBoard, isGameOver, getModalState } from \"../selectors\";\nimport { symb, throttleTime } from \"../constants\";\nimport { throttle, $id, $disabled } from \"../util/functionUtil\";\n\nconst simulateClick = buttonId => {\n  return () => {\n    const elem = buttonId\n      ? $id(buttonId) || document.activeElement\n      : document.activeElement;\n\n    if ($disabled(elem)) {\n      return;\n    }\n\n    if (elem !== document.activeElement) {\n      elem.focus();\n    }\n\n    elem.click();\n\n    if ($disabled(elem)) {\n      elem.blur(); //firefox keeps disabled buttons focused\n    }\n  };\n};\n\nconst throttledSimulateClick = throttle(throttleTime, simulateClick());\n\nconst focusSelect = () => {\n  if (document.activeElement.id !== \"mode-list\") {\n    $id(\"mode-list\").focus();\n  }\n};\n\nclass KeyBinder extends Component {\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  triggerIf = cb => () => {\n    if (this.props.shouldTrigger) {\n      cb();\n    }\n  };\n\n  move(mod, isGT) {\n    if (this.props.isGO) {\n      return;\n    }\n\n    const focusId = document.activeElement.id;\n    let selected;\n\n    if (!focusId || !focusId.startsWith(\"cell-\")) {\n      selected = this.props.board.indexOf(symb.empty);\n    } else {\n      let currIndex = parseInt(focusId.slice(5), 10);\n\n      selected = currIndex + mod;\n\n      if (selected < 0 || selected > 8) {\n        return;\n      }\n\n      if (this.props.board[selected] !== symb.empty) {\n        selected = isGT\n          ? this.props.board.indexOf(symb.empty, selected + 1)\n          : this.props.board.lastIndexOf(symb.empty, selected - 1);\n      }\n    }\n\n    if (selected > -1) {\n      $id(`cell-${selected}`).focus();\n    }\n  }\n\n  render() {\n    const moveLeft = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, -1, false))\n    );\n\n    const moveRIght = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, 1, true))\n    );\n\n    const moveUp = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, -3, false))\n    );\n\n    const moveDown = this.triggerIf(\n      throttle(throttleTime, this.move.bind(this, 3, true))\n    );\n\n    const undo = this.triggerIf(throttle(throttleTime, simulateClick(\"undo\")));\n    const redo = this.triggerIf(throttle(throttleTime, simulateClick(\"redo\")));\n\n    return (\n      <MousetrapWrapper\n        bindings={{\n          w: moveUp,\n          a: moveLeft,\n          s: moveDown,\n          d: moveRIght,\n          e: this.triggerIf(throttledSimulateClick),\n          \"ctrl+z\": undo,\n          \"ctrl+shift+z\": redo,\n          \"ctrl+y\": redo,\n          n: this.triggerIf(throttle(throttleTime, simulateClick(\"new\"))),\n          m: this.triggerIf(throttle(throttleTime, focusSelect))\n        }}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  board: getBoard(state),\n  isGO: isGameOver(state),\n  shouldTrigger: !getModalState(state)\n});\n\nexport default connect(mapStateToProps, null)(KeyBinder);\n\n\n\n// WEBPACK FOOTER //\n// ./src/containers/KeyBinder.js","import { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Mousetrap from \"mousetrap\";\n\nclass MousetrapWrapper extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      bindings: props.bindings\n    };\n  }\n\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  componentDidMount() {\n    for (let key in this.state.bindings) {\n      Mousetrap.bind(key, this.state.bindings[key]);\n    }\n  }\n\n  componentWillUnmount() {\n    for (let key in this.state.bindings) {\n      Mousetrap.unbind(key);\n    }\n  }\n\n  render() {\n    return null;\n  }\n}\n\nMousetrapWrapper.propTypes = {\n  bindings: PropTypes.objectOf(PropTypes.func)\n};\n\nexport default MousetrapWrapper;\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/MousetrapWrapper.js","/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.1\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/mousetrap/mousetrap.js\n// module id = 192\n// module chunks = 0"],"sourceRoot":""}